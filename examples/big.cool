(*
*  This file shows how to implement a list data type for lists of integers.
*  It makes use of INHERITANCE and DYNAMIC DISPATCH.
*
*  The List class has 4 operations defined on List objects. If 'l' is
*  a list, then the methods dispatched on 'l' have the following effects:
*
*    isNil() : Bool        Returns true if 'l' is empty, false otherwise.
*    head()  : Int     Returns the integer at the head of 'l'.
*              If 'l' is empty, execution aborts.
*    tail()  : List        Returns the remainder of the 'l',
*              i.e. without the first element.
*    cons(i : Int) : List  Return a new list containing i as the
*              first element, followed by the
*              elements in 'l'.
*
*  There are 2 kinds of lists, the empty list and a non-empty
*  list. We can think of the non-empty list as a specialization of
*  the empty list.
*  The class List defines the operations on empty list. The class
*  Cons inherits from List and redefines things to handle non-empty
*  lists.
*)

class List {
    -- Define operations on empty lists.
    isNil() : Bool {
        true
    };

    -- Since abort() has return type Object and head() has return type
    -- Int, we need to have an Int as the result of the method body,
    -- even though abort() never returns.

    head() : Int {
        {
            abort();
            0;
        }
    };

    -- As for head(), the self is just to make sure the return type of
    -- tail() is correct.

    cons(i : Int) : List {
    };
};

(*
*  This file shows how to implement a list data type for lists of integers.
*  It makes use of INHERITANCE and DYNAMIC DISPATCH.
*
*  The List class has 4 operations defined on List objects. If 'l' is
*  a list, then the methods dispatched on 'l' have the following effects:
*
*    isNil() : Bool        Returns true if 'l' is empty, false otherwise.
*    head()  : Int     Returns the integer at the head of 'l'.
*              If 'l' is empty, execution aborts.
*    tail()  : List        Returns the remainder of the 'l',
*              i.e. without the first element.
*    cons(i : Int) : List  Return a new list containing i as the
*              first element, followed by the
*              elements in 'l'.
*
*  There are 2 kinds of lists, the empty list and a non-empty
*  list. We can think of the non-empty list as a specialization of
*  the empty list.
*  The class List defines the operations on empty list. The class
*  Cons inherits from List and redefines things to handle non-empty
*  lists.
*)

class List {
    -- Define operations on empty lists.
    isNil() : Bool {
        true
    };

    -- Since abort() has return type Object and head() has return type
    -- Int, we need to have an Int as the result of the method body,
    -- even though abort() never returns.

    head() : Int {
        {
            abort();
            0;
        }
    };

    -- As for head(), the self is just to make sure the return type of
    -- tail() is correct.

    cons(i : Int) : List {
    };
};

(*
*  This file shows how to implement a list data type for lists of integers.
*  It makes use of INHERITANCE and DYNAMIC DISPATCH.
*
*  The List class has 4 operations defined on List objects. If 'l' is
*  a list, then the methods dispatched on 'l' have the following effects:
*
*    isNil() : Bool        Returns true if 'l' is empty, false otherwise.
*    head()  : Int     Returns the integer at the head of 'l'.
*              If 'l' is empty, execution aborts.
*    tail()  : List        Returns the remainder of the 'l',
*              i.e. without the first element.
*    cons(i : Int) : List  Return a new list containing i as the
*              first element, followed by the
*              elements in 'l'.
*
*  There are 2 kinds of lists, the empty list and a non-empty
*  list. We can think of the non-empty list as a specialization of
*  the empty list.
*  The class List defines the operations on empty list. The class
*  Cons inherits from List and redefines things to handle non-empty
*  lists.
*)

class List {
    -- Define operations on empty lists.
    isNil() : Bool {
        true
    };

    -- Since abort() has return type Object and head() has return type
    -- Int, we need to have an Int as the result of the method body,
    -- even though abort() never returns.

    head() : Int {
        {
            abort();
            0;
        }
    };

    -- As for head(), the self is just to make sure the return type of
    -- tail() is correct.

    cons(i : Int) : List {
    };
};

(*
*  This file shows how to implement a list data type for lists of integers.
*  It makes use of INHERITANCE and DYNAMIC DISPATCH.
*
*  The List class has 4 operations defined on List objects. If 'l' is
*  a list, then the methods dispatched on 'l' have the following effects:
*
*    isNil() : Bool        Returns true if 'l' is empty, false otherwise.
*    head()  : Int     Returns the integer at the head of 'l'.
*              If 'l' is empty, execution aborts.
*    tail()  : List        Returns the remainder of the 'l',
*              i.e. without the first element.
*    cons(i : Int) : List  Return a new list containing i as the
*              first element, followed by the
*              elements in 'l'.
*
*  There are 2 kinds of lists, the empty list and a non-empty
*  list. We can think of the non-empty list as a specialization of
*  the empty list.
*  The class List defines the operations on empty list. The class
*  Cons inherits from List and redefines things to handle non-empty
*  lists.
*)

class List {
    -- Define operations on empty lists.
    isNil() : Bool {
        true
    };

    -- Since abort() has return type Object and head() has return type
    -- Int, we need to have an Int as the result of the method body,
    -- even though abort() never returns.

    head() : Int {
        {
            abort();
            0;
        }
    };

    -- As for head(), the self is just to make sure the return type of
    -- tail() is correct.

    cons(i : Int) : List {
    };
};

(*
*  This file shows how to implement a list data type for lists of integers.
*  It makes use of INHERITANCE and DYNAMIC DISPATCH.
*
*  The List class has 4 operations defined on List objects. If 'l' is
*  a list, then the methods dispatched on 'l' have the following effects:
*
*    isNil() : Bool        Returns true if 'l' is empty, false otherwise.
*    head()  : Int     Returns the integer at the head of 'l'.
*              If 'l' is empty, execution aborts.
*    tail()  : List        Returns the remainder of the 'l',
*              i.e. without the first element.
*    cons(i : Int) : List  Return a new list containing i as the
*              first element, followed by the
*              elements in 'l'.
*
*  There are 2 kinds of lists, the empty list and a non-empty
*  list. We can think of the non-empty list as a specialization of
*  the empty list.
*  The class List defines the operations on empty list. The class
*  Cons inherits from List and redefines things to handle non-empty
*  lists.
*)

class List {
    -- Define operations on empty lists.
    isNil() : Bool {
        true
    };

    -- Since abort() has return type Object and head() has return type
    -- Int, we need to have an Int as the result of the method body,
    -- even though abort() never returns.

    head() : Int {
        {
            abort();
            0;
        }
    };

    -- As for head(), the self is just to make sure the return type of
    -- tail() is correct.

    cons(i : Int) : List {
    };
};

(*
*  This file shows how to implement a list data type for lists of integers.
*  It makes use of INHERITANCE and DYNAMIC DISPATCH.
*
*  The List class has 4 operations defined on List objects. If 'l' is
*  a list, then the methods dispatched on 'l' have the following effects:
*
*    isNil() : Bool        Returns true if 'l' is empty, false otherwise.
*    head()  : Int     Returns the integer at the head of 'l'.
*              If 'l' is empty, execution aborts.
*    tail()  : List        Returns the remainder of the 'l',
*              i.e. without the first element.
*    cons(i : Int) : List  Return a new list containing i as the
*              first element, followed by the
*              elements in 'l'.
*
*  There are 2 kinds of lists, the empty list and a non-empty
*  list. We can think of the non-empty list as a specialization of
*  the empty list.
*  The class List defines the operations on empty list. The class
*  Cons inherits from List and redefines things to handle non-empty
*  lists.
*)

class List {
    -- Define operations on empty lists.
    isNil() : Bool {
        true
    };

    -- Since abort() has return type Object and head() has return type
    -- Int, we need to have an Int as the result of the method body,
    -- even though abort() never returns.

    head() : Int {
        {
            abort();
            0;
        }
    };

    -- As for head(), the self is just to make sure the return type of
    -- tail() is correct.

    cons(i : Int) : List {
    };
};

(*
*  This file shows how to implement a list data type for lists of integers.
*  It makes use of INHERITANCE and DYNAMIC DISPATCH.
*
*  The List class has 4 operations defined on List objects. If 'l' is
*  a list, then the methods dispatched on 'l' have the following effects:
*
*    isNil() : Bool        Returns true if 'l' is empty, false otherwise.
*    head()  : Int     Returns the integer at the head of 'l'.
*              If 'l' is empty, execution aborts.
*    tail()  : List        Returns the remainder of the 'l',
*              i.e. without the first element.
*    cons(i : Int) : List  Return a new list containing i as the
*              first element, followed by the
*              elements in 'l'.
*
*  There are 2 kinds of lists, the empty list and a non-empty
*  list. We can think of the non-empty list as a specialization of
*  the empty list.
*  The class List defines the operations on empty list. The class
*  Cons inherits from List and redefines things to handle non-empty
*  lists.
*)

class List {
    -- Define operations on empty lists.
    isNil() : Bool {
        true
    };

    -- Since abort() has return type Object and head() has return type
    -- Int, we need to have an Int as the result of the method body,
    -- even though abort() never returns.

    head() : Int {
        {
            abort();
            0;
        }
    };

    -- As for head(), the self is just to make sure the return type of
    -- tail() is correct.

    cons(i : Int) : List {
    };
};

(*
*  This file shows how to implement a list data type for lists of integers.
*  It makes use of INHERITANCE and DYNAMIC DISPATCH.
*
*  The List class has 4 operations defined on List objects. If 'l' is
*  a list, then the methods dispatched on 'l' have the following effects:
*
*    isNil() : Bool        Returns true if 'l' is empty, false otherwise.
*    head()  : Int     Returns the integer at the head of 'l'.
*              If 'l' is empty, execution aborts.
*    tail()  : List        Returns the remainder of the 'l',
*              i.e. without the first element.
*    cons(i : Int) : List  Return a new list containing i as the
*              first element, followed by the
*              elements in 'l'.
*
*  There are 2 kinds of lists, the empty list and a non-empty
*  list. We can think of the non-empty list as a specialization of
*  the empty list.
*  The class List defines the operations on empty list. The class
*  Cons inherits from List and redefines things to handle non-empty
*  lists.
*)

class List {
    -- Define operations on empty lists.
    isNil() : Bool {
        true
    };

    -- Since abort() has return type Object and head() has return type
    -- Int, we need to have an Int as the result of the method body,
    -- even though abort() never returns.

    head() : Int {
        {
            abort();
            0;
        }
    };

    -- As for head(), the self is just to make sure the return type of
    -- tail() is correct.

    cons(i : Int) : List {
    };
};

(*
*  This file shows how to implement a list data type for lists of integers.
*  It makes use of INHERITANCE and DYNAMIC DISPATCH.
*
*  The List class has 4 operations defined on List objects. If 'l' is
*  a list, then the methods dispatched on 'l' have the following effects:
*
*    isNil() : Bool        Returns true if 'l' is empty, false otherwise.
*    head()  : Int     Returns the integer at the head of 'l'.
*              If 'l' is empty, execution aborts.
*    tail()  : List        Returns the remainder of the 'l',
*              i.e. without the first element.
*    cons(i : Int) : List  Return a new list containing i as the
*              first element, followed by the
*              elements in 'l'.
*
*  There are 2 kinds of lists, the empty list and a non-empty
*  list. We can think of the non-empty list as a specialization of
*  the empty list.
*  The class List defines the operations on empty list. The class
*  Cons inherits from List and redefines things to handle non-empty
*  lists.
*)

class List {
    -- Define operations on empty lists.
    isNil() : Bool {
        true
    };

    -- Since abort() has return type Object and head() has return type
    -- Int, we need to have an Int as the result of the method body,
    -- even though abort() never returns.

    head() : Int {
        {
            abort();
            0;
        }
    };

    -- As for head(), the self is just to make sure the return type of
    -- tail() is correct.

    cons(i : Int) : List {
    };
};

(*
*  This file shows how to implement a list data type for lists of integers.
*  It makes use of INHERITANCE and DYNAMIC DISPATCH.
*
*  The List class has 4 operations defined on List objects. If 'l' is
*  a list, then the methods dispatched on 'l' have the following effects:
*
*    isNil() : Bool        Returns true if 'l' is empty, false otherwise.
*    head()  : Int     Returns the integer at the head of 'l'.
*              If 'l' is empty, execution aborts.
*    tail()  : List        Returns the remainder of the 'l',
*              i.e. without the first element.
*    cons(i : Int) : List  Return a new list containing i as the
*              first element, followed by the
*              elements in 'l'.
*
*  There are 2 kinds of lists, the empty list and a non-empty
*  list. We can think of the non-empty list as a specialization of
*  the empty list.
*  The class List defines the operations on empty list. The class
*  Cons inherits from List and redefines things to handle non-empty
*  lists.
*)

class List {
    -- Define operations on empty lists.
    isNil() : Bool {
        true
    };

    -- Since abort() has return type Object and head() has return type
    -- Int, we need to have an Int as the result of the method body,
    -- even though abort() never returns.

    head() : Int {
        {
            abort();
            0;
        }
    };

    -- As for head(), the self is just to make sure the return type of
    -- tail() is correct.

    cons(i : Int) : List {
    };
};

(*
*  This file shows how to implement a list data type for lists of integers.
*  It makes use of INHERITANCE and DYNAMIC DISPATCH.
*
*  The List class has 4 operations defined on List objects. If 'l' is
*  a list, then the methods dispatched on 'l' have the following effects:
*
*    isNil() : Bool        Returns true if 'l' is empty, false otherwise.
*    head()  : Int     Returns the integer at the head of 'l'.
*              If 'l' is empty, execution aborts.
*    tail()  : List        Returns the remainder of the 'l',
*              i.e. without the first element.
*    cons(i : Int) : List  Return a new list containing i as the
*              first element, followed by the
*              elements in 'l'.
*
*  There are 2 kinds of lists, the empty list and a non-empty
*  list. We can think of the non-empty list as a specialization of
*  the empty list.
*  The class List defines the operations on empty list. The class
*  Cons inherits from List and redefines things to handle non-empty
*  lists.
*)

class List {
    -- Define operations on empty lists.
    isNil() : Bool {
        true
    };

    -- Since abort() has return type Object and head() has return type
    -- Int, we need to have an Int as the result of the method body,
    -- even though abort() never returns.

    head() : Int {
        {
            abort();
            0;
        }
    };

    -- As for head(), the self is just to make sure the return type of
    -- tail() is correct.

    cons(i : Int) : List {
    };
};

(*
*  This file shows how to implement a list data type for lists of integers.
*  It makes use of INHERITANCE and DYNAMIC DISPATCH.
*
*  The List class has 4 operations defined on List objects. If 'l' is
*  a list, then the methods dispatched on 'l' have the following effects:
*
*    isNil() : Bool        Returns true if 'l' is empty, false otherwise.
*    head()  : Int     Returns the integer at the head of 'l'.
*              If 'l' is empty, execution aborts.
*    tail()  : List        Returns the remainder of the 'l',
*              i.e. without the first element.
*    cons(i : Int) : List  Return a new list containing i as the
*              first element, followed by the
*              elements in 'l'.
*
*  There are 2 kinds of lists, the empty list and a non-empty
*  list. We can think of the non-empty list as a specialization of
*  the empty list.
*  The class List defines the operations on empty list. The class
*  Cons inherits from List and redefines things to handle non-empty
*  lists.
*)

class List {
    -- Define operations on empty lists.
    isNil() : Bool {
        true
    };

    -- Since abort() has return type Object and head() has return type
    -- Int, we need to have an Int as the result of the method body,
    -- even though abort() never returns.

    head() : Int {
        {
            abort();
            0;
        }
    };

    -- As for head(), the self is just to make sure the return type of
    -- tail() is correct.

    cons(i : Int) : List {
    };
};

(*
*  This file shows how to implement a list data type for lists of integers.
*  It makes use of INHERITANCE and DYNAMIC DISPATCH.
*
*  The List class has 4 operations defined on List objects. If 'l' is
*  a list, then the methods dispatched on 'l' have the following effects:
*
*    isNil() : Bool        Returns true if 'l' is empty, false otherwise.
*    head()  : Int     Returns the integer at the head of 'l'.
*              If 'l' is empty, execution aborts.
*    tail()  : List        Returns the remainder of the 'l',
*              i.e. without the first element.
*    cons(i : Int) : List  Return a new list containing i as the
*              first element, followed by the
*              elements in 'l'.
*
*  There are 2 kinds of lists, the empty list and a non-empty
*  list. We can think of the non-empty list as a specialization of
*  the empty list.
*  The class List defines the operations on empty list. The class
*  Cons inherits from List and redefines things to handle non-empty
*  lists.
*)

class List {
    -- Define operations on empty lists.
    isNil() : Bool {
        true
    };

    -- Since abort() has return type Object and head() has return type
    -- Int, we need to have an Int as the result of the method body,
    -- even though abort() never returns.

    head() : Int {
        {
            abort();
            0;
        }
    };

    -- As for head(), the self is just to make sure the return type of
    -- tail() is correct.

    cons(i : Int) : List {
    };
};

(*
*  This file shows how to implement a list data type for lists of integers.
*  It makes use of INHERITANCE and DYNAMIC DISPATCH.
*
*  The List class has 4 operations defined on List objects. If 'l' is
*  a list, then the methods dispatched on 'l' have the following effects:
*
*    isNil() : Bool        Returns true if 'l' is empty, false otherwise.
*    head()  : Int     Returns the integer at the head of 'l'.
*              If 'l' is empty, execution aborts.
*    tail()  : List        Returns the remainder of the 'l',
*              i.e. without the first element.
*    cons(i : Int) : List  Return a new list containing i as the
*              first element, followed by the
*              elements in 'l'.
*
*  There are 2 kinds of lists, the empty list and a non-empty
*  list. We can think of the non-empty list as a specialization of
*  the empty list.
*  The class List defines the operations on empty list. The class
*  Cons inherits from List and redefines things to handle non-empty
*  lists.
*)

class List {
    -- Define operations on empty lists.
    isNil() : Bool {
        true
    };

    -- Since abort() has return type Object and head() has return type
    -- Int, we need to have an Int as the result of the method body,
    -- even though abort() never returns.

    head() : Int {
        {
            abort();
            0;
        }
    };

    -- As for head(), the self is just to make sure the return type of
    -- tail() is correct.

    cons(i : Int) : List {
    };
};

(*
*  This file shows how to implement a list data type for lists of integers.
*  It makes use of INHERITANCE and DYNAMIC DISPATCH.
*
*  The List class has 4 operations defined on List objects. If 'l' is
*  a list, then the methods dispatched on 'l' have the following effects:
*
*    isNil() : Bool        Returns true if 'l' is empty, false otherwise.
*    head()  : Int     Returns the integer at the head of 'l'.
*              If 'l' is empty, execution aborts.
*    tail()  : List        Returns the remainder of the 'l',
*              i.e. without the first element.
*    cons(i : Int) : List  Return a new list containing i as the
*              first element, followed by the
*              elements in 'l'.
*
*  There are 2 kinds of lists, the empty list and a non-empty
*  list. We can think of the non-empty list as a specialization of
*  the empty list.
*  The class List defines the operations on empty list. The class
*  Cons inherits from List and redefines things to handle non-empty
*  lists.
*)

class List {
    -- Define operations on empty lists.
    isNil() : Bool {
        true
    };

    -- Since abort() has return type Object and head() has return type
    -- Int, we need to have an Int as the result of the method body,
    -- even though abort() never returns.

    head() : Int {
        {
            abort();
            0;
        }
    };

    -- As for head(), the self is just to make sure the return type of
    -- tail() is correct.

    cons(i : Int) : List {
    };
};

(*
*  This file shows how to implement a list data type for lists of integers.
*  It makes use of INHERITANCE and DYNAMIC DISPATCH.
*
*  The List class has 4 operations defined on List objects. If 'l' is
*  a list, then the methods dispatched on 'l' have the following effects:
*
*    isNil() : Bool        Returns true if 'l' is empty, false otherwise.
*    head()  : Int     Returns the integer at the head of 'l'.
*              If 'l' is empty, execution aborts.
*    tail()  : List        Returns the remainder of the 'l',
*              i.e. without the first element.
*    cons(i : Int) : List  Return a new list containing i as the
*              first element, followed by the
*              elements in 'l'.
*
*  There are 2 kinds of lists, the empty list and a non-empty
*  list. We can think of the non-empty list as a specialization of
*  the empty list.
*  The class List defines the operations on empty list. The class
*  Cons inherits from List and redefines things to handle non-empty
*  lists.
*)

class List {
    -- Define operations on empty lists.
    isNil() : Bool {
        true
    };

    -- Since abort() has return type Object and head() has return type
    -- Int, we need to have an Int as the result of the method body,
    -- even though abort() never returns.

    head() : Int {
        {
            abort();
            0;
        }
    };

    -- As for head(), the self is just to make sure the return type of
    -- tail() is correct.

    cons(i : Int) : List {
    };
};
